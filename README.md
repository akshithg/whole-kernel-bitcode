# Whole Kernel Bitcode

Generating whole-program LLVM bitcode for large projects like the Linux kernel enables advanced static analysis, optimization, and security research. However, the kernel's complex build system makes this a non-trivial task.

This post presents a practical approach for extracting **whole-kernel LLVM bitcode**, with a focus on a **design goal that avoids patching the kernel or relying on fragile tooling**.

## Design Goal

> **Depend only on the compiler and kernel build artifacts**
> No kernel patches. No special linker magic. No over-instrumentation.

This goal sets this work apart from prior tools. By working directly with `clang`, `compile_commands.json`, and kernel-generated `.built-in.a.cmd` files, we can generate whole-kernel bitcode **in the correct order** without modifying the kernel or the build system.

## My Approach

1. Compile the kernel with llvm/clang.
2. Use the `compile_commands.json` generated by clang to compile each source file into a bitcode file.
3. Using the `.built-in.a.cmd` files generated by the kernel build system, find the correct order to link the bitcode files.
4. Link the bitcode files in the correct order to generate the whole kernel bitcode.

This approach is lightweight, deterministic, and scalable. It avoids issues common to existing tools that require patching the kernel or injecting wrappers.

## Existing Tools

While this project follows a custom route, other notable tools exist:

- [`rizsotto/Bear`](https://github.com/rizsotto/Bear): Captures compile commands via `LD_PRELOAD`, producing a `compile_commands.json` database.

```bash
bear make -j$(nproc)
cat compile_commands.json | jq '.[] | .command'
```

- trailofbits/blight: A flexible toolchain wrapper to intercept and modify build commands during compilation.
- SRI-CSL/gllvm: Offers gclang and get-bc wrappers to compile and extract bitcode artifacts.
- travitch/whole-program-llvm: Focuses on whole-program analysis but requires more intrusive integration.

These tools did not work out-of-the-box with the kernel due to its size and build complexity. That motivated this tool's minimal, artifact-driven design.

## Building the Kernel

Generating whole-program LLVM bitcode for the Linux kernel requires compiling each source file to bitcode and linking them in the correct order. The first step is to build the kernel.

```bash
wget https://cdn.kernel.org/pub/linux/kernel/v6.x/linux-6.8.9.tar.xz # stable at the time of writing
tar -xf linux-6.8.9.tar.xz
cd linux-6.8.9
make defconfig
make -j$(nproc)
```

## Running the Kernel

Once built, the kernel can be tested using QEMU.

```bash
qemu-system-x86_64 -hda ubuntu-22.04-server-cloudimg-amd64.img -m 2G -enable-kvm -nographic -net nic -net user,hostfwd=tcp::2222-:22 -kernel arch/x86/boot/bzImage -append "root=/dev/sda1 console=ttyS0"
```

## LLVM Bitcode Basics

LLVM bitcode is widely used for program analysis, optimizations, and security research. It can be generated for individual source files using clang.

1. `clang -S -emit-llvm <file.c> -o <file.ll>` to get the human readable bitcode.

2. `clang -c -emit-llvm <file.c>  -o <file.bc>` to get the binary bitcode.

## Challenges in Whole-Kernel Bitcode Generation

Compiling an entire project like the Linux kernel to LLVM bitcode is non-trivial because of its complex build system. The kernel build process follows these steps:

1. Each `.c` source file is compiled into an object file—`.o`.
2. Object files within a subsystem are linked into an archive—`built-in.a`.
3. All `built-in.a` files are linked to generate the final kernel image—`vmlinux`.

To preserve the correct build order, we must capture and modify the build process dynamically.

### Summary

This project builds on LLVM tooling and kernel build artifacts to produce a link-order-preserving whole-kernel bitcode file. Unlike existing tools, it:

- Requires no kernel patches
- Avoids build system modifications
- Works directly from generated artifacts

This makes it a portable and scalable solution for large-scale program analysis and security research on the Linux kernel.
